  <!DOCTYPE html>
  <html>
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Research Questions</title>

      <link rel="stylesheet" type="text/css" href="../web/base.css" />

      <style>
        #search > div {
          margin-top: 8px;
          width: 100%;
        }

        #search input[type=text], #search button {
          padding: 4px 8px;

          background-color: #EEE;
          color: #444;
        }

        /* We cannot control the search UI, so manually calculate widths for sizing */
        #search input {
          padding-right: 4px !important; /* Pagefind likes to add a large padding here, disable it */

          width: calc(100%
                        - max(10%, 50px) /* button width */
                        - 20px /* margins */);

          border: 1px solid #EEE;
        }

        #search button {
          width: calc(max(10%, 50px));

          border: 1px solid #AAA;
        }

        /* This is the load more results button */
        #search .pagefind-ui__drawer button {
          margin-left: 0;
          margin-right: 0;
          width: 100%;
        }
      </style>
    </head>
    <body class="width40">

    <div id="search"></div>
    <hr>

<p>Based on <code>regtest/aports</code>, which is a big shell workload:</p>
<ul>
<li>Is there another <code>xz</code> backdoor lurking in the workload ?
<ul>
<li>Can we add always-on runtime instrumentation to detect this?  with <strong>O(1) memory</strong> with respect to program runtime ?</li>
<li>Theme: <strong>supply chain security</strong></li>
</ul>
</li>
<li>Shell is slow, so can we use the &quot;spaces&quot; to run telemetry / always-on profiling?
<ul>
<li>how often is shell invoked in the Alpine Linux build?  At Alpine Boot time?</li>
<li>Debian build / systemd boot ?</li>
<li>which shell features are used?</li>
<li>Theme: <strong>language runtime implementation</strong></li>
</ul>
</li>
<li>OSH is as fast as bash, despite being written in <strong>typed Python</strong> (with GC) !
<ul>
<li>This is because bash is a suboptimal program!</li>
<li>Can OSH be as fast as awk / Python?
<ul>
<li>By another translation of the executable spec?  (e.g. with tagged pointers)</li>
<li>Or with hints?  Or by enhancing the metalanguage?</li>
</ul>
</li>
</ul>
</li>
<li>How to visualize shell traces?</li>
<li>Can the Alpine Linux build with <code>abuild</code> be parallelized and distributed?
<ul>
<li>something like Bazel or Nix?</li>
<li>Theme: <strong>parallel and distributed computing</strong></li>
</ul>
</li>
<li>Can OSH be transformed to YSH?
<ul>
<li>there is no automatic design</li>
<li>Theme: <strong>program transformation</strong></li>
</ul>
</li>
<li>Can we fix bugs in OSH with LLMs?
<ul>
<li>point LLM  at busybox ash / bash source code, and ask it to implement OSH?</li>
<li>document OSH?</li>
<li>can we use the <strong>~11,000</strong>-commit history of the Oils repo to improve results?</li>
<li>problem: changes are often bottlenecked on <strong>review</strong>
<ul>
<li>case study: <code>trap</code> builtin</li>
</ul>
</li>
<li>problem: is there an objective metric for &quot;generating ugly code&quot; that's not maintainable by humans?
<ul>
<li>I guess that's why we use the commit history</li>
<li><code>trap</code> builtin is another good example</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Themes</h2>
<ul>
<li>Supply Chain Security
<ul>
<li>Foundation for a distributed OS</li>
</ul>
</li>
<li>parallel and distributed computing</li>
<li>program transformation / maintenance</li>
<li>Generating source code changes</li>
</ul>
    <script src="./pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            new PagefindUI({ element: "#search", showSubResults: true });
        });
    </script>
  </body>
</html>

